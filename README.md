# 用Node.js Java Go模拟常见的Linux网络I/O并发模型

## 目标模型

1. 单线程Accept(无 I/O复用)
2. 单线程Accept + 多线程读写业务(无 I/O复用)
3. 单线程多路I/O复用
4. 单线程多路I/O复用 + 多线程读写业务(业务工作池)
5. 单线程I/O复用 + 多线程I/O复用(连接线程池)
6. (进程版): 单进程多线程I/O复用 + 多进程程I/O复用

### 单线程Accept(无I/O复用)

- 原理: 单线程顺序处理连接的接受和读写操作，同一时间只能处理一个连接请求或读写操作
- 实现思路:
  - Node.js: `net`模块创建TCP服务器，在单个事件循环中处理所有的连接；
  - Java: `ServerSocket`监听端口，通过`Socket`处理连接；
  - Go: `net.Listen`创建监听套接字，在主goroutine中处理连接。

### 单线程Accept + 多线程读写业务(无I/O复用)

- 原理: 单线程负责接收新连接，将读写业务分配给多个线程处理，同一时间只能处理一个连接请求或读写操作
- 实现思路:
  - Node.js: 使用`worker_threads`模块创建线程池读写业务；
  - Java: 使用线程池处理读写业务；
  - Go: 为每个连接创建一个协程处理读写。

### 单线程多路I/O复用

- 原理：使用I/O复用技术在单线程中同时监听多个连接的读写事件。
- 实现思路:
  - Node.js: 基于事件循环和底层的I/O复用技术实现；
  - Java: 使用`Selector`和`ServerSocketChannel`实现；
  - Go: 使用`net`包的非阻塞I/O和goroutine实现。

### 单线程多路I/O复用 + 多线程读写业务(业务工作池)

- 原理: 单线程使用 I/O 复用监听连接事件，将读写业务分配给线程池处理。
- 实现思路:
  - Node.js: 结合事件循环和`worker_threads`模块；
  - Java: 使用`Selector`和`ServerSocketChannel`实现，将读写业务分配给线程池处理；
  - Go: 使用`net`包监听事件，将任务分配给goroutine池。

### 单线程I/O复用 + 多线程I/O复用(连接线程池)

- 原理: 创建连接线程池，每个线程使用I/O复用技术处理一部分连接
- 实现思路:
  - Node.js: 使用多个`net`服务器实例，每个实例在独立的线程中运行;
  - Java: 创建多个`Selector`线程，每个线程处理一部分连接;
  - Go: 启动多个 goroutine，每个 goroutine 监听一部分连接。

### (进程版): 单进程多线程I/O复用 + 多进程I/O复用

- 原理: 使用多进程和多线程结合I/O复用技术处理连接
- 实现思路:
  - Node.js: 使用`cluster`模块创建多个进程，每个进程内部使用多线程处理；
  - Java: 使用`ProcessBuilder`创建多个进程，每个进程内部使用线程池和Selector
  - Go: 使用`os/exec`启动多个进程，每个进程内部使用gorountine处理

## 测试指标

### 核心的测试指标

1. 性能指标: 衡量系统处理请求的能力和响应部分
   1. 吞吐量(QPS/TPS)
   2. 响应时间(RT)
   3. 平均延迟
   4. P99延迟
2. 资源消耗:
   1. CPU占用率
   2. 内存占用率
   3. 线程/进程数
   4. 上下文切换次数
3. 稳定性指标:
   1. 长连接保持能力
   2. 错误率

### 测试场景设计

1. 负载类型:
   1. 短连接场景: 模拟HTTP短链接
   2. 长连接场景: 模拟WS长链接
   3. 混合场景: 模拟HTTP短链接和WS长链接混合
2. 数据特征:
   1. 小数据包: 1KB以内
   2. 中数据包: 1MB以上
   3. 突发数据包: 1W个以上
3. 压力级别:
   1. 低并发: 100以下
   2. 中等并发: 1k-10k并发
   3. 高并发: 10k以上
